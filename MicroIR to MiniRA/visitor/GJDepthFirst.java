//
// Generated by JTB 1.3.2
//

package visitor;
import syntaxtree.*;
import java.util.*;

/**
 * Provides default methods which visit each node in the tree in depth-first
 * order.  Your visitors may extend this class.
 */


public class GJDepthFirst<R,A> implements GJVisitor<R,A> {
   //
   // Auto class visitors--probably don't need to be overridden.
   //
   Maps map;

   HashMap<String,ArrayList<usedef>> Proc_usedefs = new HashMap<String,ArrayList<usedef>>();
   HashMap<String,ArrayList<inout>> Proc_livetable = new HashMap<String,ArrayList<inout>>();
   HashMap<String,HashMap<String,int[]>> Proc_liveranges = new HashMap<String,HashMap<String,int[]>>();
   HashMap<String,Integer> labstmtind = new HashMap<String,Integer>();
   HashMap<String,HashMap<String,HashMap<Integer,Integer>>> hasSucc = new HashMap<String,HashMap<String,HashMap<Integer,Integer>>>();
   HashMap<String,ArrayList<liveness>> Proc_regs_allocd = new HashMap<String,ArrayList<liveness>>();
   HashMap<String,ArrayList<liveness>> Proc_regs_spilled = new HashMap<String,ArrayList<liveness>>();
   //HashMap<String,HashMap<String,ArrayList<regstatus>>> Proc_RegStatus = new HashMap<String,HashMap<String,ArrayList<regstatus>>>();
   //HashMap<String,Integer> Proc_maxcallnum = new HashMap<String,Integer>();
   Integer tmpflag;
   String currProcname;

   public class MyComparator implements java.util.Comparator<liveness> {

      public int compare(liveness s1, liveness s2) {
          int dist1 = s1.range[0];
          int dist2 = s2.range[0];
          if(dist1 == dist2){
            int dist11 = s1.range[1];
            int dist22 = s2.range[1];
            return dist22 - dist11;
          }
          return dist1 - dist2;
      }
  }

  public class MyComparator1 implements java.util.Comparator<liveness> {

      public int compare(liveness s1, liveness s2) {
          int dist1 = s1.range[1];
          int dist2 = s2.range[1];
          if(dist1 == dist2){
            int dist11 = s1.range[0];
            int dist22 = s2.range[0];
            return dist11 - dist22;
          }
          return dist1 - dist2;
      }
  }

   public void LinearScanRegAlloc(){
      int max_regs = 18;
      for(String fname: Proc_liveranges.keySet()){
        HashMap<String,int[]> liveranges = Proc_liveranges.get(fname);
        
        ArrayList<liveness> active = new ArrayList<liveness>();  
        ArrayList<liveness> spillstack = new ArrayList<liveness>();

        ArrayList<String> freeregpool = new ArrayList<String>();
        for(Integer num = 0;num<8;num++){
          freeregpool.add("s"+num.toString());
        }
        for(Integer num = 0;num<10;num++){
          freeregpool.add("t"+num.toString());
        }
        
        ArrayList<liveness> ranges = new ArrayList<liveness>();
        for(String key: liveranges.keySet()){
          int[] range = liveranges.get(key);
          ranges.add(new liveness(key,range));
        }
        Collections.sort(ranges,new MyComparator());
        // System.out.println(fname);
        // for(liveness x: ranges){
        //   System.out.println(x.tmp+":  "+x.range[0]+" "+x.range[1]);
        // }
        for(liveness live_i: ranges){
          //ExpireOldIntervals;
          Iterator<liveness> iter = active.iterator();
          while(iter.hasNext()){
            liveness active_i = iter.next();
            if(!(active_i.range[1] >= live_i.range[0])){
              int idx = active.indexOf(active_i);
              iter.remove();
              String reg = active_i.reg;
              freeregpool.add(reg);
              //System.out.println("==========================adding: "+reg);
            }
          }

          if(active.size()==max_regs){
            //SpillAtInterval;
            liveness spill = active.get(active.size()-1);
            if(spill.range[1] >= live_i.range[1]){
              String reg_spill = spill.reg;
              live_i.reg = reg_spill;
              spillstack.add(spill);
              int idx = active.indexOf(spill);
              if(idx != -1){
                active.remove(idx);
              }
              active.add(live_i);
              Collections.sort(active,new MyComparator1());
            }
            else{
              spillstack.add(live_i);
            }

          }
          else{
            String reg_i = freeregpool.get(0);
            live_i.reg = reg_i;
            freeregpool.remove(0);
            //System.out.println("==========================removing: "+reg_i);
            active.add(live_i);
            Collections.sort(active,new MyComparator1());
          }
        }
        Proc_regs_allocd.put(fname,ranges);
        Proc_regs_spilled.put(fname,spillstack);
      }
      builregstatus();
      //printProcregstatus();
   }

   public void builregstatus(){
    for(String fname: Proc_regs_allocd.keySet()){
      HashMap<String,ArrayList<regstatus>> hm = new HashMap<String,ArrayList<regstatus>>();
      ArrayList<liveness> arr = Proc_regs_allocd.get(fname);      
      ArrayList<regstatus> myarr = new ArrayList<regstatus>();
      for(liveness ob: arr){
        String tmp = ob.tmp;
        String reg = ob.reg;
        regstatus myreg = new regstatus(tmp,reg);
        myarr.add(myreg);
      }
      
      ArrayList<liveness> arr1 = Proc_regs_spilled.get(fname);
      ArrayList<regstatus> myarr1 = new ArrayList<regstatus>();
      ArrayList<String> torem = new ArrayList<String>();
      for(liveness ob: arr1){
        String tmp = ob.tmp;
        regstatus myreg = new regstatus(tmp,"null");
        myreg.loc = arr1.indexOf(ob);
        myarr1.add(myreg);
        torem.add(tmp); 
      }
      hm.put("spilled",myarr1);

      Iterator<regstatus> iter = myarr.iterator();
      while(iter.hasNext()){
        regstatus remreg = iter.next();
        String srem = remreg.tmp;
        if(torem.contains(srem)){
          iter.remove();
        }
      }
      hm.put("allocated",myarr);
      map.Proc_RegStatus.put(fname,hm);
    }
  }

   public void printProcregstatus(){
    for(String fname: map.Proc_RegStatus.keySet()){
      System.out.println("\n"+fname+": ");
      HashMap<String,ArrayList<regstatus>> hm = map.Proc_RegStatus.get(fname);
      ArrayList<regstatus> arr = hm.get("allocated");
      System.out.println("  allocated:");
      for(regstatus ob: arr){
        System.out.println("    "+ob.tmp+": "+ob.reg);
      }
      ArrayList<regstatus> arr1 = hm.get("spilled");
      System.out.println("  spilled:");
      for(regstatus ob: arr1){
        System.out.println("    "+ob.tmp+": "+ob.loc);
      }
    }
   }

   public boolean equalLists(List<String> one, List<String> two){     
      if (one == null && two == null){
          return true;
      }
      if((one == null && two != null) || one != null && two == null || one.size() != two.size()){
          return false;
      }
      //to avoid messing the order of the lists we will use a copy
      //as noted in comments by A. R. S.
      one = new ArrayList<String>(one); 
      two = new ArrayList<String>(two);   
      Collections.sort(one);
      Collections.sort(two);      
      return one.equals(two);
  }

  public void LiveRangesAnalysis(){
    for(String fname: Proc_livetable.keySet()){
      HashMap<String,int[]> ftmps = new HashMap<String,int[]>();

      ArrayList<inout> livetable = Proc_livetable.get(fname);
      ArrayList<String> allvars = new ArrayList<String>();
      for(inout ob: livetable){
        for(String s: ob.in){
          if(!allvars.contains(s)){
            allvars.add(s);
          }
        }
        for(String s: ob.out){
          if(!allvars.contains(s)){
            allvars.add(s);
          }
        }
      }
      //System.out.println(fname+" allvars: "+allvars.toString());
      for(String tmp: allvars){
        int[] range = new int[2]; 
        for(int i=0;i<livetable.size();i++){
          inout liveob = livetable.get(i);
          if((liveob.in).contains(tmp) || (liveob.out).contains(tmp)){
            range[0] = i;
            break;
          }
        }
        for(int i=livetable.size()-1;i>=0;i--){
          inout liveob = livetable.get(i);
          if((liveob.in).contains(tmp) || (liveob.out).contains(tmp)){
            range[1] = i;
            break;
          }
        }
        ftmps.put(tmp,range);
      }
      Proc_liveranges.put(fname,ftmps);
    }
    //printProcLiveRanges();
  }

  public void printProcLiveRanges(){
    for(String fname: Proc_liveranges.keySet()){
      System.out.println(fname+" :");
      HashMap<String,int[]> hm = Proc_liveranges.get(fname);
      for(String s: hm.keySet()){
        int[] range = hm.get(s);
        System.out.println("  "+s+": "+range[0]+" "+range[1]);
      }
    }
  }

  public void LivelinessAnalysis(){
    for(String fname: Proc_usedefs.keySet()){
      
      ArrayList<usedef> usedeftable = (Proc_usedefs.get(fname));
      
      ArrayList<inout> livetable = new ArrayList<inout>();
      for (int i = 0; i < usedeftable.size(); i ++) {
        livetable.add(new inout());
      } 
      int stop = 1;
      while(stop!=0){
        stop = 0;
        for(int i = (usedeftable.size()-1); i>=0; i--){
          inout livetable_i = livetable.get(i);
          usedef usedeftable_i = usedeftable.get(i);
          //compute outs
          ArrayList<String> oldIN = new ArrayList<String>();
          for(String oi: livetable_i.in){
            oldIN.add(oi);
          }
          ArrayList<String> oldOUT = new ArrayList<String>();
          for(String oi: livetable_i.out){
            oldOUT.add(oi);
          }

          livetable_i.out.clear();
          ArrayList<Integer> succs = new ArrayList<Integer>();
          ArrayList<Integer> tsuccs = usedeftable_i.suc;
          ArrayList<String> tdef = usedeftable_i.def;
          for(Integer uds: tsuccs){
              succs.add(uds);
          }
          ArrayList<String> newOUT = new ArrayList<String>();
          for(Integer s: succs){
            inout livetable_s = livetable.get(s);
            ArrayList<String> succIN = (livetable_s).in;
            for(String ins: succIN){
              if(!((newOUT).contains(ins))){
                (newOUT).add(ins);  
              }  
            }            
          }
          for(String itd: tdef){
              if(!((newOUT).contains(itd))){
                (newOUT).add(itd);  
              }  
            }
          livetable_i.out = newOUT;

          //compute ins
          livetable_i.in.clear();
          ArrayList<String> nOUT = (livetable_i.out);
          ArrayList<String> nDEF = (usedeftable_i).def;
          ArrayList<String> nUSE = (usedeftable_i).use;
          ArrayList<String> newIN = new ArrayList<String>();
          ArrayList<String> diffOD = new ArrayList<String>();
          for(String su: nUSE){
            if(!(newIN.contains(su))){
              newIN.add(su);
            }
          }
          for(String od: nOUT){
              diffOD.add(od);
          }
          for(String dd: nDEF){
            if(diffOD.contains(dd)){
              int idxx = diffOD.indexOf(dd);
              if(idxx != -1){
                diffOD.remove(idxx);
              }
            }
          }
          for(String sd: diffOD){
            if(!(newIN.contains(sd))){
              newIN.add(sd);
            }
          }
          livetable_i.in = newIN;
        
          if(!(equalLists(oldIN,newIN) && equalLists(oldOUT,newOUT))){
            stop += 1;
          }            

        }
        //System.out.println("stop: "+stop);
      }      
    Proc_livetable.put(fname,livetable);
    }
    //printProcLivetable();
  }   

  public void buildSucc(){
    for(String fname: Proc_usedefs.keySet()){
        
        ArrayList<usedef> arr = Proc_usedefs.get(fname);

        for(int i=0; i<arr.size(); i++){
            if(i!=arr.size()-1){
              usedef ob = arr.get(i);
              (ob.suc).add(i+1);  
            }
        }
        if(hasSucc.containsKey(fname)){
          HashMap<String,HashMap<Integer,Integer>> HSM = hasSucc.get(fname);
          HashMap<Integer,Integer> succs_cj = HSM.get("cjump");
          HashMap<Integer,Integer> succs_j = HSM.get("jump");
          for(int i=0; i<arr.size(); i++){
            usedef ob = arr.get(i);
            if(succs_cj.containsKey(i)){
              int s = succs_cj.get(i);
              if(!((ob.suc).contains(s))){
                (ob.suc).add(s);  
              }
            }
            if(succs_j.containsKey(i)){
              int s = succs_j.get(i);
              if(!((ob.suc).contains(s))){
                (ob.suc).add(s);
                int rm = (ob.suc).indexOf(i+1);
                if(rm != -1){
                  (ob.suc).remove(rm);  
                }
              }
            }
          }  
        }
    }
    //printProcUD();
  }

   public void printProcUD(){
      for(String fname: Proc_usedefs.keySet()){
        System.out.println(fname+" :");
        ArrayList<usedef> arr = Proc_usedefs.get(fname);
        for(int i=0; i<arr.size(); i++){
          usedef ob = arr.get(i);
          System.out.print("  "+i+".  def:"+" "+ob.def.toString());
          System.out.print("    use:"+" "+ob.use.toString());
          System.out.println("    suc:"+" "+ob.suc.toString());
        }
        System.out.println();    
      }
   }

   public void printProcLivetable(){
      for(String fname: Proc_livetable.keySet()){
        System.out.println(fname+" :");
        ArrayList<inout> arr = Proc_livetable.get(fname);
        for(int i=0; i<arr.size(); i++){
          inout ob = arr.get(i);
          System.out.print("  "+i+".  in:"+" "+ob.in.toString());
          System.out.println("    out:"+" "+ob.out.toString());
        }
        System.out.println();    
      }
   }

   public GJDepthFirst(HashMap<String,Integer> lab, Maps map){
      this.labstmtind = lab;
      this.tmpflag = 0;
      this.currProcname = "";
      this.map = map;
   }

   public R visit(NodeList n, A argu) {
      R _ret=null;
      int _count=0;
      for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
         e.nextElement().accept(this,argu);
         _count++;
      }
      return _ret;
   }

   public R visit(NodeListOptional n, A argu) {
      if ( n.present() ) {
         R _ret=null;
         int _count=0;
         for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
            e.nextElement().accept(this,argu);
            _count++;
         }
         return _ret;
      }
      else
         return null;
   }

   public R visit(NodeOptional n, A argu) {
      if ( n.present() )
         return n.node.accept(this,argu);
      else
         return null;
   }

   public R visit(NodeSequence n, A argu) {
      R _ret=null;
      int _count=0;
      for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
         e.nextElement().accept(this,argu);
         _count++;
      }
      return _ret;
   }

   public R visit(NodeToken n, A argu) { return null; }

   //
   // User-generated visitor methods below
   //

   /**
    * f0 -> "MAIN"
    * f1 -> StmtList()
    * f2 -> "END"
    * f3 -> ( Procedure() )*
    * f4 -> <EOF>
    */
   public R visit(Goal n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      currProcname = "MAIN";
      ArrayList<usedef> arr = new ArrayList<usedef>();
      n.f1.accept(this, (A)arr);
      n.f2.accept(this, argu);
      currProcname = "";
      Proc_usedefs.put("MAIN",arr);
      argu = null;
      n.f3.accept(this, argu);
      n.f4.accept(this, argu);
      //System.out.println("\nhasSucc: "+hasSucc.toString());
      //printProcUD();
      buildSucc();      
      LivelinessAnalysis();
      LiveRangesAnalysis();
      LinearScanRegAlloc();
      //System.out.println("\ncallargnum: "+map.Proc_maxcallnum.toString());
      //_ret = (R)map;
      return _ret;
   }

   /**
    * f0 -> ( ( Label() )? Stmt() )*
    */
   public R visit(StmtList n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> Label()
    * f1 -> "["
    * f2 -> IntegerLiteral()
    * f3 -> "]"
    * f4 -> StmtExp()
    */
   public R visit(Procedure n, A argu) {
      R _ret=null;
      String fname = n.f0.f0.toString();
      currProcname = fname;
      ArrayList<usedef> arr = new ArrayList<usedef>();
      n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      n.f3.accept(this, argu);
      n.f4.accept(this, (A)arr);
      Proc_usedefs.put(fname,arr);
      currProcname = "";
      return _ret;
   }

   /**
    * f0 -> NoOpStmt()
    *       | ErrorStmt()
    *       | CJumpStmt()
    *       | JumpStmt()
    *       | HStoreStmt()
    *       | HLoadStmt()
    *       | MoveStmt()
    *       | PrintStmt()
    */
   public R visit(Stmt n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "NOOP"
    */
   public R visit(NoOpStmt n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      usedef ud = new usedef();
      ((ArrayList<usedef>)argu).add(ud);
      return _ret;
   }

   /**
    * f0 -> "ERROR"
    */
   public R visit(ErrorStmt n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      usedef ud = new usedef();
      ((ArrayList<usedef>)argu).add(ud);
      return _ret;
   }

   /**
    * f0 -> "CJUMP"
    * f1 -> Temp()
    * f2 -> Label()
    */
   public R visit(CJumpStmt n, A argu) {
      R _ret=null;    //TODO Successor
      n.f0.accept(this, argu);
      String t = n.f1.accept(this, argu).toString();
      usedef ud = new usedef();
      ud.use.add(t);
      int arrsize = ((ArrayList<usedef>)argu).size();
      ((ArrayList<usedef>)argu).add(ud);
      String lab = n.f2.f0.toString();
      int gotoind = labstmtind.get(lab);
      HashMap<String,HashMap<Integer,Integer>> HSM = new HashMap<String,HashMap<Integer,Integer>>(); 
      HashMap<Integer,Integer> hm = new HashMap<Integer,Integer>();
      if(hasSucc.containsKey(currProcname)){
        HSM = (hasSucc.get(currProcname));
        if(HSM.containsKey("cjump")){
          hm = HSM.get("cjump");  
        }
      }      
      hm.put(arrsize,gotoind);
      HSM.put("cjump",hm);
      hasSucc.put(currProcname,HSM);
      return _ret;
   }

   /**
    * f0 -> "JUMP"
    * f1 -> Label()
    */
   public R visit(JumpStmt n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      String lab = n.f1.f0.toString();
      int arrsize = ((ArrayList<usedef>)argu).size();
      usedef ud = new usedef();
      ((ArrayList<usedef>)argu).add(ud);
      int gotoind = labstmtind.get(lab);
      HashMap<String,HashMap<Integer,Integer>> HSM = new HashMap<String,HashMap<Integer,Integer>>(); 
      HashMap<Integer,Integer> hm = new HashMap<Integer,Integer>();
      if(hasSucc.containsKey(currProcname)){
        HSM = hasSucc.get(currProcname);
        if(HSM.containsKey("jump")){
          hm = HSM.get("jump");  
        }        
      }      
      hm.put(arrsize,gotoind);
      HSM.put("jump",hm);
      hasSucc.put(currProcname,HSM);
      return _ret;
   }

   /**
    * f0 -> "HSTORE"
    * f1 -> Temp()
    * f2 -> IntegerLiteral()
    * f3 -> Temp()
    */
   public R visit(HStoreStmt n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      String t1 = n.f1.accept(this, argu).toString();
      n.f2.accept(this, argu);
      String t2 = n.f3.accept(this, argu).toString();
      usedef ud = new usedef();
      ud.use.add(t1);
      ud.use.add(t2);
      ((ArrayList<usedef>)argu).add(ud);
      return _ret;
   }

   /**
    * f0 -> "HLOAD"
    * f1 -> Temp()
    * f2 -> Temp()
    * f3 -> IntegerLiteral()
    */
   public R visit(HLoadStmt n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      String t1 = n.f1.accept(this, argu).toString();
      String t2 = n.f2.accept(this, argu).toString();
      n.f3.accept(this, argu);
      usedef ud = new usedef();
      ud.def.add(t1);
      ud.use.add(t2);
      ((ArrayList<usedef>)argu).add(ud);
      return _ret;
   }

   /**
    * f0 -> "MOVE"
    * f1 -> Temp()
    * f2 -> Exp()
    */
   public R visit(MoveStmt n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      ArrayList<usedef> argucopy = ((ArrayList<usedef>)argu);
      String t = n.f1.accept(this, argu).toString();
      usedef ud = new usedef();
      ud.def.add(t);
      if(n.f2.f0.which == 3){
        String t1 = n.f2.accept(this, argu).toString();
        if(t1.contains("TEMP")){
          ud.use.add(t1);
        }
      }
      else{
        n.f2.accept(this, (A)ud);
      }
      argucopy.add(ud);
      argu = (A)argucopy;
      return _ret;
   }

   /**
    * f0 -> "PRINT"
    * f1 -> SimpleExp()
    */
   public R visit(PrintStmt n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      if(n.f1.f0.which == 0){
        String t1 = n.f1.accept(this, argu).toString();
        usedef ud = new usedef();
        ud.use.add(t1);
        ((ArrayList<usedef>)argu).add(ud);
      }
      else{
        n.f1.accept(this, argu);
        usedef ud = new usedef();
        ((ArrayList<usedef>)argu).add(ud);
      }
      return _ret;
   }

   /**
    * f0 -> Call()
    *       | HAllocate()
    *       | BinOp()
    *       | SimpleExp()
    */
   public R visit(Exp n, A argu) {
      R _ret=null;
      if(n.f0.which == 3){
        _ret = (R)(n.f0.accept(this, argu).toString());
      }
      else{
        n.f0.accept(this, argu);
      }
      return _ret;
   }

   /**
    * f0 -> "BEGIN"
    * f1 -> StmtList()
    * f2 -> "RETURN"
    * f3 -> SimpleExp()
    * f4 -> "END"
    */
   public R visit(StmtExp n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      if(n.f3.f0.which == 0){
        usedef ud = new usedef();
        String t = n.f3.accept(this, argu).toString();
        ud.use.add(t);
        ((ArrayList<usedef>)argu).add(ud); 
      }
      else{
        n.f4.accept(this, argu);  
      }
      n.f4.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "CALL"
    * f1 -> SimpleExp()
    * f2 -> "("
    * f3 -> ( Temp() )*
    * f4 -> ")"
    */
   public R visit(Call n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      if(n.f1.f0.which == 0){
        String t = n.f1.accept(this, argu).toString();
        ((usedef)argu).use.add(t);
      }
      n.f2.accept(this, argu);
      tmpflag = 1;
      n.f3.accept(this, argu);
      tmpflag = 0;  
      n.f4.accept(this, argu);
      int callargnum = ((usedef)argu).use.size()-1;
      if(map.Proc_maxcallnum.containsKey(currProcname)){
        int exists = map.Proc_maxcallnum.get(currProcname);
        if(exists<callargnum){
          map.Proc_maxcallnum.put(currProcname,callargnum);
        }
      }
      else{
        map.Proc_maxcallnum.put(currProcname,callargnum);
      }
      return _ret;
   }

   /**
    * f0 -> "HALLOCATE"
    * f1 -> SimpleExp()
    */
   public R visit(HAllocate n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      if(n.f1.f0.which == 0){
        String t = n.f1.accept(this, argu).toString();
        ((usedef)argu).use.add(t);
      }
      return _ret;
   }

   /**
    * f0 -> Operator()
    * f1 -> Temp()
    * f2 -> SimpleExp()
    */
   public R visit(BinOp n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      String t1 = n.f1.accept(this, argu).toString();
      ((usedef)argu).use.add(t1);
      if(n.f2.f0.which == 0){
        String t2 = n.f2.accept(this, argu).toString();
        ((usedef)argu).use.add(t2);
      }
      return _ret;
   }

   /**
    * f0 -> "LE"
    *       | "NE"
    *       | "PLUS"
    *       | "MINUS"
    *       | "TIMES"
    *       | "DIV"
    */
   public R visit(Operator n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> Temp()
    *       | IntegerLiteral()
    *       | Label()
    */
   public R visit(SimpleExp n, A argu) {
      R _ret=null;
      _ret = (R)(n.f0.accept(this, argu).toString());
      return _ret;
   }

   /**
    * f0 -> "TEMP"
    * f1 -> IntegerLiteral()
    */
   public R visit(Temp n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      String a = n.f1.accept(this, argu).toString();
      _ret = (R)("TEMP "+a);
      if(tmpflag == 1){
        ((usedef)argu).use.add("TEMP "+a);
      }
      return _ret;
   }

   /**
    * f0 -> <INTEGER_LITERAL>
    */
   public R visit(IntegerLiteral n, A argu) {
      R _ret=null;
      _ret = (R)(n.f0.toString());
      return _ret;
   }

   /**
    * f0 -> <IDENTIFIER>
    */
   public R visit(Label n, A argu) {
      R _ret=null;
      _ret = (R)(n.f0.toString());
      return _ret;
   }

}
